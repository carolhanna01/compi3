%{

	/* Declarations section */
	#include "hw3_output.hpp"
	#include "scopes.h"

	#include <iostream>
	#include <stdlib.h>
	
	using namespace output;
	using namespace scopeTables;
	
	extern int yylex();
	int yyerror(const char * message);
%}

%token	  VOID
%token    INT
%token    BYTE
%token    B
%token    BOOL
%token    RETURN 
%token    WHILE 
%token    BREAK 
%token    CONTINUE 
%token    SC
%token	  ENUM
%token    COMMA 
%token    LBRACE 
%token    RBRACE 
%token    ID 
%token    NUM 
%token    STRING 
%right    ASSIGN 
%left	  OR 
%left     AND
%left	  EQUALITY
%nonassoc RELATION
%left	  ADD SUB
%left     MUL DIV
%right    NOT 
%left	  LPAREN RPAREN 
%nonassoc IF 
%nonassoc ELSE
%left TRUE FALSE 

/*
	Doneth list - 1, 2, 3, 4, 11, 12, 13
*/ 


%% /*Rules*/
Program			:	Enums Funcs{};

Funcs			:	/*epsilon*/{}
				|	FuncDecl Funcs{};	
			
FuncDecl		:	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE{};

Enums			:	/*epsilon*/{};
				|	EnumDecl Enums {$$ = new enumEntry();};

EnumDecl		:	ENUM ID LBRACE EnumeratorList RBRACE SC{};
	
RetType			:	Type {$$ = $1}
				|	VOID {$$ = new variableEntry("", "VOID");};
	
Formals			:	/*epsilon*/{}
				|	FormalsList{};
			
FormalsList		:	FormalDecl{}
				|	FormalDecl COMMA FormalsList{};
	
FormalDecl 		:	Type ID{}
				|	EnumType ID{};
	
EnumeratorList	:	Enumerator {$$->type.maxValue++;}
				|	EnumeratorList COMMA Enumerator {$$->type.maxValue++;};
	
Enumerator		:	ID;
	
Statements		:	Statement{}
				|	Statements Statement{}

Statement		:	LBRACE Statements RBRACE{}
				|	Type ID SC {
						if (recursiveSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						scopes.top()->insertVariable($1->type, $2->name, offsets.top());
						offsets.top()++;
					}
				|	EnumType ID SC {
						if (!enumSearch(scopes, $1->name)) {
							errorUndefEnum(yylineno, $2->name);
							exit(0);
						}
						else if (recursiveSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						scopes.top()->insertVariable($1->type, $2->name, offsets.top());
						offsets.top()++;
					}
				|	EnumDecl{}
				|	Type ID ASSIGN Exp SC { 
						if (recursiveSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						else if ($1->type != $4 ->type && ($1->type != "INT" || $4->type != "BOOL" $)) {
							errorMismatch(yylineno); //TODO check
							exit(0);
						}
						scopes.top()->insertVariable($1->type, $2->name, offsets.top());
						offsets.top()++;
					}
				|	EnumType ID ASSIGN Exp SC {
						if (!enumSearch(scopes, $1->name)) {
							errorUndefEnum(yylineno, $2->name);
							exit(0);
						}
						else if (recursiveSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						scopes.top()->insertVariable($1->type, $2->name, offsets.top());
						offsets.top()++;
					}
				|	ID ASSIGN Exp SC {
						variableEntry* var = getVariable($1->name);
						if (!var) {
							errorUndef(yylineno, $1->name);
							exit(0);
						}
						else if (var->type != $3 ->type && (var->type != "INT" || $3->type != "BOOL" $)) {
							errorMismatch(yylineno); //TODO check
							exit(0);
						}
					}
				|	Call SC{}
				|	RETURN SC {
						if (scopes.top()->currentFunc->returnType != "VOID"){
							errorMismatch(yylineno);
							exit(0);
						}
					}
				|	RETURN Exp SC {
						if (scopes.top()->currentFunc->returnType == "VOID"){
							errorMismatch(yylineno);
							exit(0);
						}
					}
				|	IF LPAREN Exp RPAREN {addScope()} Statement {removeScope()} ELSE {addScope()} Statement {}
				|	IF LPAREN Exp RPAREN {addScope()} Statement {removeScope()} {}
				|	WHILE LPAREN Exp RPAREN Statement{}
				|	BREAK SC{
						if(scopes.top()->insideLoop == false){
							errorUnexpectedBreak(yylineno);
							exit(0);
						}
					}
					
				|	CONTINUE SC{
						if(scopes.top()->insideLoop == false){
							errorUnexpectedContinue(yylineno);
							exit(0);
						}
				};
	
Call 			:	ID LPAREN ExpList RPAREN { }
				|	ID LPAREN RPAREN {

					};
	
ExpList 		:	Exp{}
				|	Exp COMMA ExpList{};
	
Type 			:	INT{$$ = new variableEntry("", "INT")}
				|	BYTE{$$ = new variableEntry("", "BYTE")}
							//todo: add errorCheck for byte value (need to add field to entry?)}
				|	BOOL{$$ = new variableEntry("", "BOOL")};
	
EnumType 		:	ENUM ID {$$ = new variableEntry("", "ENUM");};
	
Exp 			:	LPAREN Exp RPAREN {$$= $2;}
				|	Exp MUL Exp {$$ = dealWithBinop($1, $2);}
				|	Exp DIV Exp {$$ = dealWithBinop($1, $2);}
				|	Exp ADD Exp {$$ = dealWithBinop($1, $2);}
				|	Exp SUB Exp {$$ = dealWithBinop($1, $2);}
				|	ID { 
						//todo - get table top, find variable
						$$ = new variableEntry("", //todo);
					}
				|	Call { 
						$$ = $1; 
					}
				|	NUM {$$ = new variableEntry("", "INT");}
				|	NUM B {$$ = new variableEntry("", "BYTE");}
				|	STRING {$$ = new variableEntry("", "STRING");}
				|	TRUE {$$ = new variableEntry("", "BOOL");}
				|	FALSE {$$ = new variableEntry("", "BOOL");}
				|	NOT Exp {$$ = dealWithBoolOutput($2, "BOOL");}
				|	Exp AND Exp {$$ = dealwithBoolOutput($1, $3, "BOOL");}
				|	Exp OR Exp {$$ = dealwithBoolOutput($1, $3, "BOOL");}
				|	Exp EQUALITY Exp {$$ = dealwithBoolOutput($1, $3, "INT");}
				|	Exp RELATION Exp {$$ = dealwithBoolOutput($1, $3, "INT");}
				|	LPAREN Type RPAREN Exp { 
						if ($2->type != "INT" || $4->type != "ENUM") {
							//todo what error for bad casing?
						}
						//todo do the numbering thing mentioned in the rule
					}; 
%%

main(){
    //~~~~~~~~~~~~ instancing Tables for handling scopes ~~~~~~~~~~~~//

    //instance & initialize scope stack
    scope* s = new scope();
    stack<scope*> scopes = stack<scope*>();
    scopes.push(s);

    //instance & initialize scope stack
    stack<int> offsets= stack<int>();
    offsets.push(0);
	
	// Add print and printi library functions
	
	//print
	functionType printType = functionType("VOID", std::vector<string>());
	printType.addParam("STRING");
	functionEntry  printEntry = functionEntry("print", printType);
	tables.top()->insertFunction(printEntry);

	//printi
	functionType printiType = functionType("VOID", std::vector<string>());
	printiType.addParam("INT");
	functionEntry  printiEntry = functionEntry("printi", printiType);
	tables.top()->insertFunction(printiEntry);
	
	yyparse();
	functionEntry* checkMain = tables.top()->getFunction("main");

	if (checkMain == NULL || checkMain->paramTypes.size()!=0 || checkMain->returnType != "VOID"){
		errorMainMissing();
		return 0;
	}
	endScope();
	tables.top()->printFunctions();
	tables.pop(); 
	offsets.pop();
	return 0;
}

int yyerror(const char * message)
{
	extern int yylineno;
	errorSyn(yylineno);
	exit(0);
}

bool variableSearch(stack<scope*> *scopes, string name) {
	if (scopes->empty()) {
		return false;
	}
	else if (scopes.top()->getVariable(name)) {
		return true;
	}

	scope.pop();
	bool res = variableSearch(scopes, name);
	scope.push(s);
	return res;
}

bool enumSearch(stack<Scope*> *scopes, string name) {
	if (scopes->empty()) {
		return false;
	}
	else if (scopes->top()->getEnum(name)) {
		return true;
	}

	Scope s = scopes->pop();
	bool res = enumSearch(scopes, name);
	scopes->push(s);
	return res;
}


YYSTYPE dealwithBoolOutput(YYSTYPE left,  YYSTYPE right, string check_for) {
	if (right && right->type != check_for) {
		errorMismatch(yylineno);
		exit(0);
	}
	else if (left || right->type != check_for) {
		errorMismatch(yylineno);
		exit(0);
	}
	return new variableEntry("", "BOOL");
}

YYSTYPE dealWithBinop(YYSTYPE left, YYSTYPE right) {
	if ((left->type != "INT" && left->type != "BYTE") || (right->type != "INT" && right->type != "BYTE")) {
		errorMismatch(yylineno); //TODO check
		exit(0);
	}
	string type = (left->type == "BYTE" && right->type == "BYTE") ? "BYTE" : "INT";
	return new variableEntry("", type);
}







