%{
	/* Declarations section */
	#include <iostream>
	#include <stdlib.h>
	#include <algorithm>
	#include "scopes.h"

	/* DEBUG DECLERATION AREA */
	using std::cout;
	using std::cin;
	using std::endl;


	using namespace output;
	using namespace scopeTables;

	extern int yylex();
	int yyerror(const char * message);

	stack<Scope*> scopes;
	stack<int> offsets;
	stack<vector<string>> funcParameterStack;
	functionEntry newFunction = functionEntry();
	variableEntry newVariable = variableEntry();
	enumEntry newEnum = enumEntry();

	variableEntry* variableSearch(stack<Scope*> *scopes, string name);
    enumEntry* enumSearch(stack<Scope*> *scopes, string name);
	enumEntry* enumSearchWithEnumeration(stack<Scope*> *scopes, string enumeration);
	bool similarParameters(const vector<string>& expected, const vector<string>& actual);
	int yyerror(const char * message);
	int getEnumValue(const vector<string>& enumerations, const string& name);
	YYSTYPE dealWithBinop(YYSTYPE left, YYSTYPE right);
	YYSTYPE dealwithBoolOutput(string check_for, YYSTYPE left,  YYSTYPE right = NULL);

	void addScope (stack<Scope*>& scopes, stack<int>& offsets);
	void removeScope (stack<Scope*>& scopes, stack<int>& offsets);

%}

%token	  VOID
%token    INT
%token    BYTE
%token    B
%token    BOOL
%token    RETURN 
%token    WHILE 
%token    BREAK 
%token    CONTINUE 
%token    SC
%token	  ENUM
%token    COMMA 
%token    LBRACE 
%token    RBRACE 
%token    ID 
%token    NUM 
%token    STRING 
%right    ASSIGN 
%left	  OR 
%left     AND
%left	  EQUALITY
%nonassoc RELATION
%left	  ADD SUB
%left     MUL DIV
%right    NOT 
%left	  LPAREN RPAREN 
%nonassoc IF 
%nonassoc ELSE
%left TRUE FALSE 

/*
	Doneth list - 1, 2, 3, 4, 11, 12, 13
*/ 

//TODO - offsets!
%% /*Rules*/
Program			:	Enums Funcs;

Funcs			:	/*epsilon*/
				|	FuncDecl Funcs;	
			
FuncDecl		:	RetType ID {
						if (scopes.top()->getVariable($2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						newFunction.name = $2->name;
						newFunction.type.returnType = $1->type;
						newFunction.type.paramTypes = vector<string>();
						addScope(scopes, offsets);
					} LPAREN Formals RPAREN LBRACE Statements RBRACE {
						removeScope(scopes, offsets);
						scopes.top()->insertFunction(newFunction);
					};

Enums			:	/*epsilon*/{};
				|	EnumDecl Enums {};

EnumDecl		:	ENUM ID {
						if (enumSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}	
					} LBRACE EnumeratorList RBRACE SC {
						newEnum.name = $2->name;
						scopes.top()->insertEnum(newEnum);
					};
	
RetType			:	Type {$$ = $1;}
				|	VOID {$$ = new variableEntry("", "VOID");};
	
Formals			:	/*epsilon*/
				|	FormalsList;
			
FormalsList		:	FormalDecl
				|	FormalDecl COMMA FormalsList;
	
FormalDecl 		:	Type ID {
						//TODO can var be func name?'
                        newVariable = variableEntry($2->name, $1->type,  /*todo offset*/0);
						scopes.top()->insertVariable(newVariable);
                        newFunction.type.addParam($1->type);
					}
				|	EnumType ID {
						newVariable = variableEntry($2->name, $1->type,  /*todo offset*/0);
						scopes.top()->insertVariable(newVariable);
						newFunction.type.addParam($1->type);
					};

EnumeratorList	:	Enumerator { 
						newEnum.name = "";
						newEnum.type.values = vector<string>(1, $1->name);
                    }
				|	EnumeratorList COMMA Enumerator { 
						vector<string>& enum_values = newEnum.type.values;
						if (std::find(enum_values.begin(), enum_values.end(), $3->name) != enum_values.end()) {
							errorDef(yylineno, $3->name);
							exit(0);
						}
						enum_values.push_back($3->name);
					};		

Enumerator		:	ID;
	
Statements		:	Statement
				|	Statements Statement;

Statement		:	LBRACE {
						addScope(scopes, offsets);
					} Statements {
						removeScope(scopes, offsets);
					} RBRACE
				|	Type ID SC {
						if (variableSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
                        newVariable = variableEntry($2->name, $1->type, offsets.top());
						scopes.top()->insertVariable(newVariable);
						offsets.top()++;
					}
				|	EnumType ID SC {
						if (!enumSearch(&scopes, $1->name)) {
							errorUndefEnum(yylineno, $2->name);
							exit(0);
						}
						else if (variableSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
                        newVariable= variableEntry($2->name, $1->type, offsets.top());
						scopes.top()->insertVariable(newVariable);
						offsets.top()++;
					}

				|	EnumDecl
				|	Type ID ASSIGN Exp SC {  // TODO - check if all Exp result in adding to scope as requested.
						if (variableSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						else if ($1->type != $4 ->type && ($1->type != "INT" || $4->type != "BOOL")) {
							errorMismatch(yylineno); //TODO check
							exit(0);
						}
                        newVariable= variableEntry($2->name, $1->type, offsets.top());
						scopes.top()->insertVariable(newVariable);
						offsets.top()++;
					}
				|	EnumType ID ASSIGN Exp SC {
						enumEntry* enum_entry = enumSearch(&scopes, $1->name);
						if (!enum_entry) {
							errorUndefEnum(yylineno, $2->name);
							exit(0);
						}
						else if (variableSearch(&scopes, $2->name)) {
							errorDef(yylineno, $2->name);
							exit(0);
						}
						else if ($3->type != "ENUM") { //TODO - is this necessary? Can I insert numbers? Should i check if its valid string? Enumeration?
							errorUndefEnumValue(yylineno, $2->name);
							exit(0);
						}
                        newVariable = variableEntry($2->name, $1->type, offsets.top(), $3->value);

						scopes.top()->insertVariable(newVariable);
						offsets.top()++;
					}
				|	ID ASSIGN Exp SC {
						// cout << "HERE FOR VARIABLE" << $1->name << endl;
						// scopes.top()->printVariables();
						variableEntry* var = variableSearch(&scopes, $1->name);
						if (!var) {
							errorUndef(yylineno, $1->name);
							exit(0);
						}
						else if (var->type != $3 ->type && (var->type != "INT" || $3->type != "BOOL")) {
							errorMismatch(yylineno); 
							exit(0);
						}
					}
				|	Call SC
				|	RETURN SC {
						if (scopes.top()->currentFunc->returnType != "VOID"){
							errorMismatch(yylineno);
							exit(0);
						}
					}
				|	RETURN Exp SC {
						if (scopes.top()->currentFunc->returnType != $2->type && (scopes.top()->currentFunc->returnType != "INT" || $2->type != "BYTE")){
							errorMismatch(yylineno);
							exit(0);
						}
					}
				|	IF LPAREN Exp {
						if ($3->type != "BOOL") {
							errorMismatch(yylineno);
							exit(0);
						}
					} RPAREN {
						addScope(scopes, offsets);
					} Statement {
						removeScope(scopes, offsets);
					} ELSE {
						addScope(scopes, offsets);
					} Statement {
						removeScope(scopes, offsets);
					}
				|	IF LPAREN Exp {
						if ($3->type != "BOOL") {
							errorMismatch(yylineno);
							exit(0);
						}
					} RPAREN {
						addScope(scopes, offsets);
					} Statement {
						removeScope(scopes, offsets);
					}
				|	WHILE LPAREN Exp {
						if ($3->type != "BOOL") {
							errorMismatch(yylineno);
							exit(0);
						}
					} RPAREN {
						addScope(scopes, offsets);
						scopes.top()->insideLoop = true;
					} Statement {
						removeScope(scopes, offsets);
					}
				|	BREAK SC {
						if(scopes.top()->insideLoop == false){
							errorUnexpectedBreak(yylineno);
							exit(0);
						}
					}
					
				|	CONTINUE SC {
						if(scopes.top()->insideLoop == false){
							errorUnexpectedContinue(yylineno);
							exit(0);
						}
					};
						
Call 			:	ID {
						funcParameterStack.push(vector<string>());
					} LPAREN ExpList RPAREN {
						functionEntry* f = scopes.top()->getFunction($1->name);
						if(!f) {
							errorUndefFunc(yylineno, $1->name);
							exit(0);
						} else if (!similarParameters(f->type.paramTypes, funcParameterStack.top())) {
							errorPrototypeMismatch(yylineno, $1->name, f->type.paramTypes);
							exit(0);
						}
						funcParameterStack.pop();
						$$ = new variableEntry("", f->type.returnType);
					}
				|	ID LPAREN RPAREN {
						functionEntry* f = scopes.top()->getFunction($1->name);
						if(!f) {
							errorUndefFunc(yylineno, $1->name);
							exit(0);
						} else if (f->type.paramTypes.size() != 0) {
							errorPrototypeMismatch(yylineno, $1->name, f->type.paramTypes); //todo: make sure this line is ok
							exit(0);
						}
						$$ = new variableEntry("", f->type.returnType);
					};

ExpList 		:	Exp {
						funcParameterStack.top().push_back($1->type);
					}
				|	Exp COMMA ExpList {
						funcParameterStack.top().push_back($1->type);
					};

Type 			:	INT{$$ = new variableEntry("", "INT");}
				|	BYTE{$$ = new variableEntry("", "BYTE");}
							//todo: add errorCheck for byte value (need to add field to entry?)}
				|	BOOL{$$ = new variableEntry("", "BOOL");};
	
EnumType 		:	ENUM ID {$$ = new variableEntry("", "ENUM");};
	
Exp 			:	LPAREN Exp RPAREN {$$= $2;}
				|	Exp MUL Exp {$$ = dealWithBinop($1, $2);}
				|	Exp DIV Exp {$$ = dealWithBinop($1, $2);}
				|	Exp ADD Exp {$$ = dealWithBinop($1, $2);}
				|	Exp SUB Exp {$$ = dealWithBinop($1, $2);}
				|	ID { 
						variableEntry* var = variableSearch(&scopes, $1->name);
						if (!var) {
							errorUndef(yylineno, $1->name);
						}
						$$ = new variableEntry(var->name, var->type, var->offset, var->value);
					}  
				|	Call { 
						$$ = $1; 
					}
				|	NUM {$$ = new variableEntry("", "INT");}
				|	NUM B {$$ = new variableEntry("", "BYTE");}
				|	STRING {$$ = new variableEntry("", "STRING");}
				|	TRUE {$$ = new variableEntry("", "BOOL");}
				|	FALSE {$$ = new variableEntry("", "BOOL");}
				|	NOT Exp {$$ = dealwithBoolOutput("BOOL", $2);}
				|	Exp AND Exp {$$ = dealwithBoolOutput("BOOL", $1, $3);}
				|	Exp OR Exp {$$ = dealwithBoolOutput("BOOL", $1, $3);}
				|	Exp EQUALITY Exp {$$ = dealwithBoolOutput("INT", $1, $3);}
				|	Exp RELATION Exp {$$ = dealwithBoolOutput("INT", $1, $3);}
				|	LPAREN Type RPAREN Exp { 
						if ($2->type != "INT") { // CONVERSION IS NOT TO INT
							errorMismatch(yylineno); //TODO - is this the right error?
							exit(0);
						} //TODO - make sure all enum assignments get requested value.

						variableEntry* var = variableSearch(&scopes, $4->name); //TODO - below assumes a variable cant have an enum name. True?
						enumEntry* enum_entry = enumSearchWithEnumeration(&scopes, $4->name); //TODO - make sure i cant insert same enum values for more than one enum.
						if (var && var->type == "ENUM") { // CONVERSION IS FROM VARIABLE
							$$ = new variableEntry("", "INT", 0, var->value);
						}
						else if (enum_entry) { //CONVERSION IS FROM AN ENUMERATION STRING
							int enum_value = getEnumValue(enum_entry->type.values, $4->name);
							$$ = new variableEntry("", "INT", 0, enum_value);
						}
						else {
							errorMismatch(yylineno); 
							exit(0);
						}						

					}; 
%%

main(){
    //~~~~~~~~~~~~ instancing Tables for handling scopes ~~~~~~~~~~~~//

    // instance & initialize scope stack
    Scope* s = new Scope();
    scopes = stack<Scope*>();
    scopes.push(s);

    // instance & initialize scope stack
    offsets= stack<int>();
    offsets.push(0);
	
	// Add print and printi library functions
	// print
	functionType printType = functionType("VOID", std::vector<string>());
	printType.addParam("STRING");
	functionEntry  printEntry = functionEntry("print", printType);
	scopes.top()->insertFunction(printEntry);

	// printi
	functionType printiType = functionType("VOID", std::vector<string>());
	printiType.addParam("INT");
	functionEntry  printiEntry = functionEntry("printi", printiType);
	scopes.top()->insertFunction(printiEntry);
	
	yyparse();
	functionEntry* checkMain = scopes.top()->getFunction("main");

	if (checkMain == NULL || checkMain->type.paramTypes.size()!=0 || checkMain->type.returnType != "VOID"){
		errorMainMissing();
		return 0;
	}
}

int yyerror(const char * message) {
	errorSyn(yylineno);
	exit(0);
}

variableEntry* variableSearch(stack<Scope*> *scopes, string name) {
	if (scopes->empty()) {
		return NULL;
	}
	variableEntry* entry = scopes->top()->getVariable(name);

	if (entry) {
		return entry;
	}

	Scope* s = scopes->top();
	scopes->pop();
	variableEntry* res = variableSearch(scopes, name);
	scopes->push(s);
	return res;
}

enumEntry* enumSearch(stack<Scope*> *scopes, string name) {
	if (scopes->empty()) {
		return NULL;
	}
	enumEntry* entry = scopes->top()->getEnum(name); 
	if (entry) {
		return entry;
	}

	Scope* s = scopes->top();
	scopes->pop();
	entry = enumSearch(scopes, name);
	scopes->push(s);
	return entry;
}

enumEntry* enumSearchWithEnumeration(stack<Scope*> *scopes, string enumeration) {
	if (scopes->empty()) {
		return NULL;
	}
	enumEntry* entry = scopes->top()->getEnumWithEnumeration(enumeration); 
	if (entry) {
		return entry;
	}

	Scope* s = scopes->top();
	scopes->pop();
	entry = enumSearch(scopes, enumeration);
	scopes->push(s);
	return entry; 
}

bool similarParameters(const vector<string>& expected, const vector<string>& actual) {
	if (expected.size() != actual.size()) {
		return false;
	}
	vector<string>::const_iterator expected_iter = expected.begin();
	vector<string>::const_iterator actual_iter = actual.begin();
	while (expected_iter != expected.end()) {
		if (*expected_iter != *actual_iter && (*expected_iter != "INT" || *actual_iter != "BYTE")) 
			return false;
		expected_iter++;
		actual_iter++;
	}
	return true;
}

int getEnumValue(const vector<string>& enumerations, const string& name) {
	int val= 0;
	vector<string>::const_iterator it;
	for (it = enumerations.cbegin(); it != enumerations.cend(); ++it) {
		if (!name.compare(*it)) {
			return val;
		}
		++val;
	}
}

YYSTYPE dealwithBoolOutput(string check_for, YYSTYPE left, YYSTYPE right) {
	if (right && right->type != check_for) {
		errorMismatch(yylineno);
		exit(0);
	}
	else if (left && left->type != check_for) {
		errorMismatch(yylineno);
		exit(0);
	}
	return new variableEntry("", "BOOL");
}

YYSTYPE dealWithBinop(YYSTYPE left, YYSTYPE right) {
	if ((left->type != "INT" && left->type != "BYTE") || (right->type != "INT" && right->type != "BYTE")) {
		errorMismatch(yylineno); //TODO check
		exit(0);
	}
	string type = left->type == "BYTE" && right->type == "BYTE" ? "BYTE" : "INT";
	return new variableEntry("", type);
}

void addScope (stack<Scope*>& scopes, stack<int>& offsets){
    scopes.push(new Scope(*scopes.top()));
    offsets.push(offsets.top());
}

void removeScope (stack<Scope*>& scopes, stack<int>& offsets){
    endScope();
    scopes.top()->printVariables();
    scopes.top()->printEnums();
    scopes.pop();
    offsets.pop();
}
